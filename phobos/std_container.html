<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.container - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="/js/codemirror-compressed.js"></script>
<script src="/js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a), lastName(b));
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="/images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul><li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos 2.064.2</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul><li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul><li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul><li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul><li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language//edit/master/std/container.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/Phobos/StdContainer" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.container</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/container.d -->
Defines generic containers.
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/container.d">std/container.d</a>
<p></p>
<b>License:</b><br>Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at <a href="http://boost.org/LICENSE_1_0.txt">boost.org/LICENSE_1_0.txt</a>).

<p></p>
<b>Authors:</b><br>Steven Schveighoffer, <a href="http://erdani.com">Andrei Alexandrescu</a>
<p></p>

<table cellspacing=0 cellpadding=5 class=book><caption>Container primitives. Below, <span class="d_inlinecode">C</span> means
a container type, <span class="d_inlinecode">c</span> is a value of container type, <span class="d_inlinecode">n<sub>x</sub></span> represents the effective length of value <span class="d_inlinecode">x</span>, which could be a
single element (in which case <span class="d_inlinecode">n<sub>x</sub></span> is <span class="d_inlinecode">1</span>), a container,
or a range.</caption><p></p>

<tr><th>Syntax</th> <th><b><i>&Omicron;</i>(</b><span class="d_inlinecode">&middot;</span><b><i>)</i></b></th> <th>Description</th></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">C(x)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>x</sub></span></td> <td valign=top>Creates a
container of type <span class="d_inlinecode">C</span> from either another container or a range.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.dup</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td> <td valign=top>Returns a
duplicate of the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c ~ x</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub> + n<sub>x</sub></span></td> <td valign=top>Returns the concatenation of <span class="d_inlinecode">c</span> and <span class="d_inlinecode">r</span>. <span class="d_inlinecode">x</span> may be a single
element or an input range.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">x ~ c</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub> + n<sub>x</sub></span></td> <td valign=top>Returns the concatenation of <span class="d_inlinecode">x</span> and <span class="d_inlinecode">c</span>.  <span class="d_inlinecode">x</span> may be a
single element or an input range type.</td></tr>
<p></p>

<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Iteration</em></b></td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.Range</span></td> <td valign=top></td> <td valign=top>The primary range
type associated with the container.</td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c[]</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns a range
iterating over the entire container, in a container-defined order.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c[a .. b]</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Fetches a
portion of the container from key <span class="d_inlinecode">a</span> to key <span class="d_inlinecode">b</span>.</td></tr>
<p></p>

<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Capacity</em></b></td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.empty</span></td> <td valign=top><span class="d_inlinecode">1</span></td> <td valign=top>Returns <span class="d_inlinecode"><b>true</b></span> if the
container has no elements, <span class="d_inlinecode"><b>false</b></span> otherwise.</td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.length</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns the
number of elements in the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.length = n</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub> + n</span></td> <td valign=top>Forces
the number of elements in the container to <span class="d_inlinecode">n</span>. If the container
ends up growing, the added elements are initialized in a
container-dependent manner (usually with <span class="d_inlinecode">T.init</span>).</td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.capacity</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns the
maximum number of elements that can be stored in the container
without triggering a reallocation.</td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.reserve(x)</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub></span></td> <td valign=top>Forces <span class="d_inlinecode">capacity</span> to at least <span class="d_inlinecode">x</span> without reducing it.</td></tr>
<p></p>

<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Access</em></b></td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.front</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns the
first element of the container, in a container-defined order.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.moveFront</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Destructively reads and returns the first element of the
container. The slot is not removed from the container; it is left
initalized with <span class="d_inlinecode">T.init</span>. This routine need not be defined if <span class="d_inlinecode">front</span> returns a <span class="d_inlinecode">ref</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.front = v</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Assigns
<span class="d_inlinecode">v</span> to the first element of the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.back</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns the
last element of the container, in a container-defined order.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.moveBack</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Destructively reads and returns the last element of the
<a name="container"></a><span class="ddoc_psymbol">container</span>. The slot is not removed from the container; it is left
initalized with <span class="d_inlinecode">T.init</span>. This routine need not be defined if <span class="d_inlinecode">front</span> returns a <span class="d_inlinecode">ref</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.back = v</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Assigns
<span class="d_inlinecode">v</span> to the last element of the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c[x]</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Provides
indexed access into the container. The index type is
container-defined. A <a name="container"></a><span class="ddoc_psymbol">container</span> may define several index types (and
consequently overloaded indexing).</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.moveAt(x)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Destructively reads and returns the value at position <span class="d_inlinecode">x</span>. The slot
is not removed from the container; it is left initialized with <span class="d_inlinecode">T.init</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c[x] = v</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Sets
element at specified index into the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c[x] <i>op</i>= v</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Performs read-modify-write operation at specified index into the
container.</td></tr>
<p></p>

<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Operations</em></b></td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">e in c</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns nonzero if e is found in <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.lowerBound(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns a range of all elements strictly less than <span class="d_inlinecode">v</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.upperBound(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns a range of all elements strictly greater than <span class="d_inlinecode">v</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.equalRange(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns a range of all elements in <span class="d_inlinecode">c</span> that are equal to <span class="d_inlinecode">v</span>.</td></tr>
<p></p>

<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Modifiers</em></b></td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c ~= x</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub> + n<sub>x</sub></span></td>
<td valign=top>Appends <span class="d_inlinecode">x</span> to <span class="d_inlinecode">c</span>. <span class="d_inlinecode">x</span> may be a single element or an
input range type.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.clear()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td> <td valign=top>Removes all
elements in <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.insert(x)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>x</sub> * log n<sub>c</sub></span></td>
<td valign=top>Inserts <span class="d_inlinecode">x</span> in <span class="d_inlinecode">c</span> at a position (or positions) chosen by <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableInsert(x)</span></td>
<td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>x</sub> * log n<sub>c</sub></span></td> <td valign=top>Same as <span class="d_inlinecode">c.insert(x)</span>,
but is guaranteed to not invalidate any ranges.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.linearInsert(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td> <td valign=top>Same
as <span class="d_inlinecode">c.insert(v)</span> but relaxes complexity to linear.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableLinearInsert(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.stableInsert(v)</span> but relaxes complexity to linear.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.removeAny()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Removes some element from <span class="d_inlinecode">c</span> and returns it.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableRemoveAny()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.removeAny()</span>, but is guaranteed to not invalidate any
iterators.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.insertFront(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Inserts <span class="d_inlinecode">v</span> at the front of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableInsertFront(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.insertFront(v)</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.insertBack(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Inserts <span class="d_inlinecode">v</span> at the back of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableInsertBack(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.insertBack(v)</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.removeFront()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Removes the element at the front of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableRemoveFront()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.removeFront()</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.removeBack()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Removes the value at the back of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableRemoveBack()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.removeBack()</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.remove(r)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>r</sub> * log n<sub>c</sub></span></td>
<td valign=top>Removes range <span class="d_inlinecode">r</span> from <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableRemove(r)</span></td>
<td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>r</sub> * log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.remove(r)</span>, but guarantees iterators are not
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.linearRemove(r)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td>
<td valign=top>Removes range <span class="d_inlinecode">r</span> from <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableLinearRemove(r)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.linearRemove(r)</span>, but guarantees iterators are not
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.removeKey(k)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Removes an element from <span class="d_inlinecode">c</span> by using its key <span class="d_inlinecode">k</span>.
The key's type is defined by the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode"></span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode"></span></td> <td valign=top></td></tr>
<p></p>

</table><p></p>

<dl><dt class="d_decl"><a name=".make"></a>template <a name="make"></a><span class="ddoc_psymbol">make</span>(T) if (is(T == struct) || is(T == class))</dt>
<dd>Returns an initialized object. This function is mainly for eliminating
construction differences between structs and classes. It allows code to not
worry about whether the type it's constructing is a struct or a class.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> arr = <span class="d_psymbol">make</span>!(Array!<span class="d_keyword">int</span>)([4, 2, 3, 1]);
<span class="d_keyword">assert</span>(equal(arr[], [4, 2, 3, 1]));

<span class="d_keyword">auto</span> rbt = <span class="d_psymbol">make</span>!(RedBlackTree!(<span class="d_keyword">int</span>, <span class="d_string">"a &gt; b"</span>))([4, 2, 3, 1]);
<span class="d_keyword">assert</span>(equal(rbt[], [4, 3, 2, 1]));

<span class="d_keyword">alias</span> <span class="d_psymbol">make</span>!(DList!<span class="d_keyword">int</span>) makeList;
<span class="d_keyword">auto</span> list = makeList([1, 7, 42]);
<span class="d_keyword">assert</span>(equal(list[], [1, 7, 42]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".SList"></a>struct <a name="SList"></a><span class="ddoc_psymbol">SList</span>(T);
</dt>
<dd>Implements a simple and fast singly-linked list.<p></p>

<dl><dt class="d_decl"><a name=".this"></a> this(U)(U[] <i>values</i>...) if (isImplicitlyConvertible!(U, T));
</dt>
<dd>Constructor taking a number of nodes<p></p>

</dd>
<dt class="d_decl"><a name=".this"></a> this(Stuff)(Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T) &amp;&amp; !is(Stuff == T[]));
</dt>
<dd>Constructor taking an input range<p></p>

</dd>
<dt class="d_decl"><a name=".opEquals"></a>const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(const SList <i>rhs</i>);
<br><a name=".opEquals"></a>const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const SList <i>rhs</i>);
</dt>
<dd>Comparison for equality.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">min(n, n1)</span><b><i>)</i></b> where <span class="d_inlinecode">n1</span> is the number of
elements in <span class="d_inlinecode"><i>rhs</i></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Range"></a>struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</dt>
<dd>Defines the container's primary range, which embodies a forward range.<p></p>

<dl><dt class="d_decl"><a name=".empty"></a>const bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".front"></a>T <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".front"></a>void <a name="front"></a><span class="ddoc_psymbol">front</span>(T <i>value</i>);
<br><a name=".popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd>Input range primitives.<p></p>

</dd>
<dt class="d_decl"><a name=".save"></a>Range <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd>Forward range primitive.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".empty"></a>const bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has no
elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".dup"></a>SList <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</dt>
<dd>Duplicates the container. The elements themselves are not transitively
duplicated.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd>Returns a range that iterates over all elements of the container, in
forward order.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".front"></a>T <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span></span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".front"></a>void <a name="front"></a><span class="ddoc_psymbol">front</span>(T <i>value</i>);
</dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span>(<i>value</i>)</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opBinary"></a>SList <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op, Stuff)(Stuff <i>rhs</i>) if (op == "~" &amp;&amp; is(typeof(SList(<i>rhs</i>))));
</dt>
<dd>Returns a new <span class="d_inlinecode">SList</span> that's the concatenation of <span class="d_inlinecode">this</span> and its
argument. <span class="d_inlinecode">opBinaryRight</span> is only defined if <span class="d_inlinecode">Stuff</span> does not
define <span class="d_inlinecode"><a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</dt>
<dd>Removes all contents from the <span class="d_inlinecode">SList</span>.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".insertFront"></a>size_t <a name="insertFront"></a><span class="ddoc_psymbol">insertFront</span>(Stuff)(Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T));
<br><a name=".insertFront"></a>size_t <a name="insertFront"></a><span class="ddoc_psymbol">insertFront</span>(Stuff)(Stuff <i>stuff</i>) if (isImplicitlyConvertible!(Stuff, T));
<br><a name=".insert"></a>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span> = insertFront;
<br><a name=".stableInsert"></a>alias <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span> = insert;
<br><a name=".stableInsertFront"></a>alias <a name="stableInsertFront"></a><span class="ddoc_psymbol">stableInsertFront</span> = insertFront;
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> to the front of the container. <span class="d_inlinecode">stuff</span> can be a
value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that ranges
iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".removeAny"></a>T <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
<br><a name=".stableRemoveAny"></a>alias <a name="stableRemoveAny"></a><span class="ddoc_psymbol">stableRemoveAny</span> = removeAny;
</dt>
<dd>Picks one value from the front of the container, removes it from the
container, and returns it.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".removeFront"></a>void <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>();
<br><a name=".stableRemoveFront"></a>alias <a name="stableRemoveFront"></a><span class="ddoc_psymbol">stableRemoveFront</span> = removeFront;
</dt>
<dd>Removes the value at the front of the container. The stable version
behaves the same, but guarantees that ranges iterating over the
container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".removeFront"></a>size_t <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>(size_t <i>howMany</i>);
<br><a name=".stableRemoveFront"></a>alias <a name="stableRemoveFront"></a><span class="ddoc_psymbol">stableRemoveFront</span> = removeFront;
</dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
container. Unlike the unparameterized versions above, these functions
do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span> elements. Instead,
if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are removed. The returned value is
the effective number of elements removed. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>howMany</i> * log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".insertAfter"></a>size_t <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> after range <span class="d_inlinecode">r</span>, which must be a range
previously extracted from this container. Given that all ranges for a
list end at the end of the list, this function essentially appends to
the list and uses <span class="d_inlinecode">r</span> as a potentially fast way to reach the last
node in the list. Ideally <span class="d_inlinecode">r</span> is positioned near or at the last
element of the list.
<p></p>
<span class="d_inlinecode">stuff</span> can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects
convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but
guarantees that ranges iterating over the container are never
invalidated.

<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">k + m</span><b><i>)</i></b>, where <span class="d_inlinecode">k</span> is the number of elements in
<span class="d_inlinecode">r</span> and <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span>.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> sl = SList!string([<span class="d_string">"a"</span>, <span class="d_string">"b"</span>, <span class="d_string">"d"</span>]);
sl.<span class="d_psymbol">insertAfter</span>(sl[], <span class="d_string">"e"</span>); <span class="d_comment">// insert at the end (slowest)
</span><span class="d_keyword">assert</span>(std.algorithm.equal(sl[], [<span class="d_string">"a"</span>, <span class="d_string">"b"</span>, <span class="d_string">"d"</span>, <span class="d_string">"e"</span>]));
sl.<span class="d_psymbol">insertAfter</span>(std.range.take(sl[], 2), <span class="d_string">"c"</span>); <span class="d_comment">// insert after "b"
</span><span class="d_keyword">assert</span>(std.algorithm.equal(sl[], [<span class="d_string">"a"</span>, <span class="d_string">"b"</span>, <span class="d_string">"c"</span>, <span class="d_string">"d"</span>, <span class="d_string">"e"</span>]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".insertAfter"></a>size_t <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)(Take!Range <i>r</i>, Stuff <i>stuff</i>);
<br><a name=".stableInsertAfter"></a>alias <a name="stableInsertAfter"></a><span class="ddoc_psymbol">stableInsertAfter</span> = insertAfter;
</dt>
<dd>Similar to <span class="d_inlinecode"><a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span></span> above, but accepts a range bounded in
count. This is important for ensuring fast insertions in the middle of
the list.  For fast insertions after a specified position <span class="d_inlinecode">r</span>, use
<span class="d_inlinecode"><a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(take(r, 1), stuff)</span>. The complexity of that operation
only depends on the number of elements in <span class="d_inlinecode">stuff</span>.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">r.original.empty || r.maxLength &gt; 0</span>

<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">k + m</span><b><i>)</i></b>, where <span class="d_inlinecode">k</span> is the number of elements in
<span class="d_inlinecode">r</span> and <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".linearRemove"></a>Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Range <i>r</i>);
</dt>
<dd>Removes a range from the list in linear time.
<p></p>
<b>Returns:</b><br>An empty range.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".linearRemove"></a>Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Take!Range <i>r</i>);
<br><a name=".stableLinearRemove"></a>alias <a name="stableLinearRemove"></a><span class="ddoc_psymbol">stableLinearRemove</span> = linearRemove;
</dt>
<dd>Removes a <span class="d_inlinecode">Take!Range</span> from the list in linear time.
<p></p>
<b>Returns:</b><br>A range comprehending the elements after the removed range.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".DList"></a>struct <a name="DList"></a><span class="ddoc_psymbol">DList</span>(T);
</dt>
<dd>Implements a doubly-linked list.
<p></p>
<span class="d_inlinecode"><a name="DList"></a><span class="ddoc_psymbol">DList</span></span> uses neither reference nor value semantics. They can be seen as
several different handles into an external chain of nodes. Several different
<span class="d_inlinecode"><a name="DList"></a><span class="ddoc_psymbol">DList</span></span>s can all reference different points in a same chain.
<p></p>

<span class="d_inlinecode"><a name="DList"></a><span class="ddoc_psymbol">DList</span>.Range</span> is, for all intents and purposes, a <a name="DList"></a><span class="ddoc_psymbol">DList</span> with range
semantics. The <span class="d_inlinecode"><a name="DList"></a><span class="ddoc_psymbol">DList</span>.Range</span> has a view directly into the chain itself.
It is not tied to its parent <span class="d_inlinecode"><a name="DList"></a><span class="ddoc_psymbol">DList</span></span>, and may be used to operate on
other lists (that point to the same chain).
<p></p>

The ONLY operation that can invalidate a <span class="d_inlinecode"><a name="DList"></a><span class="ddoc_psymbol">DList</span></span> or <span class="d_inlinecode"><a name="DList"></a><span class="ddoc_psymbol">DList</span>.Range</span>, but
which will invalidate BOTH, is the <span class="d_inlinecode">remove</span> operation, if the cut Range
overlaps with the boundaries of another <a name="DList"></a><span class="ddoc_psymbol">DList</span> or <a name="DList"></a><span class="ddoc_psymbol">DList</span>.Range.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> a = <span class="d_psymbol">DList</span>!<span class="d_keyword">int</span>([3, 4]); <span class="d_comment">//Create a new chain
</span><span class="d_keyword">auto</span> b = a; <span class="d_comment">//Point to the same chain
</span><span class="d_comment">// (3 - 4)
</span><span class="d_keyword">assert</span>(a[].equal([3, 4]));
<span class="d_keyword">assert</span>(b[].equal([3, 4]));

b.stableInsertFront(1); <span class="d_comment">//insert before of b
</span>b.stableInsertBack(5); <span class="d_comment">//insert after of b
</span><span class="d_comment">// (2 - (3 - 4) - 5)
</span><span class="d_keyword">assert</span>(a[].equal([3, 4])); <span class="d_comment">//a is not changed
</span><span class="d_keyword">assert</span>(b[].equal([1, 3, 4, 5])); <span class="d_comment">// but b is changed
</span>
a.stableInsertFront(2); <span class="d_comment">//insert in front of a, this will insert "inside" the chain
</span><span class="d_comment">// (1 - (2 - 3 - 4) - 5)
</span><span class="d_keyword">assert</span>(a[].equal([2, 3, 4])); <span class="d_comment">//a is modified
</span><span class="d_keyword">assert</span>(b[].equal([1, 2, 3, 4, 5])); <span class="d_comment">//and so is b;
</span>
a.remove(a[]); <span class="d_comment">//remove all the elements of a: This will cut them from the chain;
</span><span class="d_comment">// (1 - 5)
</span><span class="d_keyword">assert</span>(a[].empty); <span class="d_comment">//a is empty
</span><span class="d_keyword">assert</span>(b[].equal([1, 5])); <span class="d_comment">//b has lost some of its elements;
</span>
a.insert(2); <span class="d_comment">//insert in a. This will create a new chain
</span><span class="d_comment">// (2)
</span><span class="d_comment">// (1 - 5)
</span><span class="d_keyword">assert</span>(a[].equal([2])); <span class="d_comment">//a is a new chain
</span><span class="d_keyword">assert</span>(b[].equal([1, 5])); <span class="d_comment">//b is unchanged;
</span></pre>
<p></p>

<dl><dt class="d_decl"><a name=".this"></a> this(U)(U[] <i>values</i>...) if (isImplicitlyConvertible!(U, T));
</dt>
<dd>Constructor taking a number of nodes<p></p>

</dd>
<dt class="d_decl"><a name=".this"></a> this(Stuff)(Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T) &amp;&amp; !is(Stuff == T[]));
</dt>
<dd>Constructor taking an input range<p></p>

</dd>
<dt class="d_decl"><a name=".opEquals"></a>const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const DList <i>rhs</i>);
</dt>
<dd>Comparison for equality.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">min(n, n1)</span><b><i>)</i></b> where <span class="d_inlinecode">n1</span> is the number of
elements in <span class="d_inlinecode"><i>rhs</i></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Range"></a>struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</dt>
<dd>Defines the container's primary range, which embodies a bidirectional range.<p></p>

<dl><dt class="d_decl"><a name=".empty"></a>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".front"></a>T <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".front"></a>void <a name="front"></a><span class="ddoc_psymbol">front</span>(T <i>value</i>);
<br><a name=".popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd>Input range primitives.<p></p>

</dd>
<dt class="d_decl"><a name=".save"></a>Range <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd>Forward range primitive.<p></p>

</dd>
<dt class="d_decl"><a name=".back"></a>T <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".back"></a>void <a name="back"></a><span class="ddoc_psymbol">back</span>(T <i>value</i>);
<br><a name=".popBack"></a>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
</dt>
<dd>Bidirectional range primitives.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".empty"></a>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has no
elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".dup"></a>DList <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</dt>
<dd>Duplicates the container. The elements themselves are not transitively
duplicated.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd>Returns a range that iterates over all elements of the container, in
forward order.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".front"></a>T <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span></span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".front"></a>void <a name="front"></a><span class="ddoc_psymbol">front</span>(T <i>value</i>);
</dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span>(<i>value</i>)</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".back"></a>T <a name="back"></a><span class="ddoc_psymbol">back</span>();
</dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="back"></a><span class="ddoc_psymbol">back</span></span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".back"></a>void <a name="back"></a><span class="ddoc_psymbol">back</span>(T <i>value</i>);
</dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="back"></a><span class="ddoc_psymbol">back</span>(<i>value</i>)</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opBinary"></a>DList <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op, Stuff)(Stuff <i>rhs</i>) if (op == "~" &amp;&amp; isImplicitlyConvertible!(Stuff, T));
<br><a name=".opBinary"></a>DList <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op, Stuff)(Stuff <i>rhs</i>) if (op == "~" &amp;&amp; (is(Stuff == DList) || is(typeof(DList(<i>rhs</i>)))));
</dt>
<dd>Returns a new <span class="d_inlinecode">DList</span> that's the concatenation of <span class="d_inlinecode">this</span> and its
argument.<p></p>

</dd>
<dt class="d_decl"><a name=".opBinaryRight"></a>DList <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(string op, Stuff)(Stuff <i>rhs</i>) if (op == "~" &amp;&amp; isImplicitlyConvertible!(Stuff, T));
<br><a name=".opBinaryRight"></a>DList <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(string op, Stuff)(Stuff <i>rhs</i>) if (op == "~" &amp;&amp; isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T));
</dt>
<dd>Returns a new <span class="d_inlinecode">DList</span> that's the concatenation of the argument and <span class="d_inlinecode">this</span><p></p>

</dd>
<dt class="d_decl"><a name=".opOpAssign"></a>DList <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op, Stuff)(Stuff <i>rhs</i>) if (op == "~" &amp;&amp; isImplicitlyConvertible!(Stuff, T));
<br><a name=".opOpAssign"></a>DList <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op, Stuff)(Stuff <i>rhs</i>) if (op == "~" &amp;&amp; isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T));
</dt>
<dd>Appends the contents of stuff into this.<p></p>

</dd>
<dt class="d_decl"><a name=".clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</dt>
<dd>Removes all contents from the <span class="d_inlinecode">DList</span>.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".insertFront"></a>size_t <a name="insertFront"></a><span class="ddoc_psymbol">insertFront</span>(Stuff)(Stuff <i>stuff</i>);
<br><a name=".insertBack"></a>size_t <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff)(Stuff <i>stuff</i>);
<br><a name=".insert"></a>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span> = insertBack;
<br><a name=".stableInsert"></a>alias <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span> = insert;
<br><a name=".stableInsertFront"></a>alias <a name="stableInsertFront"></a><span class="ddoc_psymbol">stableInsertFront</span> = insertFront;
<br><a name=".stableInsertBack"></a>alias <a name="stableInsertBack"></a><span class="ddoc_psymbol">stableInsertBack</span> = insertBack;
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> to the front/back of the container. <span class="d_inlinecode">stuff</span> can be a
value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that ranges
iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".removeAny"></a>T <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
<br><a name=".stableRemoveAny"></a>alias <a name="stableRemoveAny"></a><span class="ddoc_psymbol">stableRemoveAny</span> = removeAny;
</dt>
<dd>Picks one value from the front of the container, removes it from the
container, and returns it.
<p></p>
Elements are not actually removed from the chain, but the <span class="d_inlinecode">DList</span>'s,
first/last pointer is advanced.

<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".removeFront"></a>void <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>();
<br><a name=".stableRemoveFront"></a>alias <a name="stableRemoveFront"></a><span class="ddoc_psymbol">stableRemoveFront</span> = removeFront;
<br><a name=".removeBack"></a>void <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>();
<br><a name=".stableRemoveBack"></a>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span> = removeBack;
</dt>
<dd>Removes the value at the front/back of the container. The stable version
behaves the same, but guarantees that ranges iterating over the
container are never invalidated.
<p></p>
Elements are not actually removed from the chain, but the <span class="d_inlinecode">DList</span>'s,
first/last pointer is advanced.

<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".removeFront"></a>size_t <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>(size_t <i>howMany</i>);
<br><a name=".stableRemoveFront"></a>alias <a name="stableRemoveFront"></a><span class="ddoc_psymbol">stableRemoveFront</span> = removeFront;
<br><a name=".removeBack"></a>size_t <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>(size_t <i>howMany</i>);
<br><a name=".stableRemoveBack"></a>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span> = removeBack;
</dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
container. Unlike the unparameterized versions above, these functions
do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span> elements. Instead,
if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are removed. The returned value is
the effective number of elements removed. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
Elements are not actually removed from the chain, but the <span class="d_inlinecode">DList</span>'s,
first/last pointer is advanced.

<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>howMany</i> * log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".insertBefore"></a>size_t <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br><a name=".stableInsertBefore"></a>alias <a name="stableInsertBefore"></a><span class="ddoc_psymbol">stableInsertBefore</span> = insertBefore;
<br><a name=".insertAfter"></a>size_t <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br><a name=".stableInsertAfter"></a>alias <a name="stableInsertAfter"></a><span class="ddoc_psymbol">stableInsertAfter</span> = insertAfter;
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> after range <span class="d_inlinecode">r</span>, which must be a non-empty range
previously extracted from this container.
<p></p>
<span class="d_inlinecode">stuff</span> can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects
convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but
guarantees that ranges iterating over the container are never
invalidated.
<p></p>

Elements are not actually removed from the chain, but the <span class="d_inlinecode">DList</span>'s,
first/last pointer is advanced.

<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">k + m</span><b><i>)</i></b>, where <span class="d_inlinecode">k</span> is the number of elements in
<span class="d_inlinecode">r</span> and <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".remove"></a>Range <a name="remove"></a><span class="ddoc_psymbol">remove</span>(Range <i>r</i>);
<br><a name=".linearRemove"></a>Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(R)(R <i>r</i>) if (is(R == Range));
<br><a name=".linearRemove"></a>Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(R)(R <i>r</i>) if (is(R == Range));
</dt>
<dd>Removes all elements belonging to <span class="d_inlinecode"><i>r</i></span>, which must be a range
obtained originally from this container.
<p></p>
This function actually removes the elements from the chain. This is the
only function that may invalidate a range, as it cuts the chain of elements:
Ranges (and other DList) that contain <span class="d_inlinecode"><i>r</i></span> or that are inside <span class="d_inlinecode"><i>r</i></span>,
as well a <span class="d_inlinecode"><i>r</i></span> itself, are never invalidated.
Ranges (and other DList) which partially overlap with <span class="d_inlinecode"><i>r</i></span> will be cut,
and invalidated.

<p></p>
<b>Returns:</b><br>A range spanning the remaining elements in the container that
initially were right after <span class="d_inlinecode"><i>r</i></span>.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".linearRemove"></a>Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(R)(R <i>r</i>) if (is(R == Take!Range));
</dt>
<dd><span class="d_inlinecode"><a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span></span> functions as <span class="d_inlinecode">remove</span>, but also accepts ranges that are
result the of a <span class="d_inlinecode">take</span> operation. This is a convenient way to remove a
fixed amount of elements from the range.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.walkLength</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".stableRemove"></a>alias <a name="stableRemove"></a><span class="ddoc_psymbol">stableRemove</span> = remove;
<br><a name=".stableLinearRemove"></a>alias <a name="stableLinearRemove"></a><span class="ddoc_psymbol">stableLinearRemove</span> = linearRemove;
</dt>
<dd><span style="color:red">Scheduled for deprecation. These methods are not actually stable.
    Use the standard <span class="d_inlinecode">remove</span> or <span class="d_inlinecode">linearRemove</span> instead.</span><p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Array"></a>struct <a name="Array"></a><span class="ddoc_psymbol">Array</span>(T) if (!is(T : const(bool)));
</dt>
<dd><a name="Array"></a><span class="ddoc_psymbol">Array</span> type with deterministic control of memory. The memory allocated
for the array is reclaimed as soon as possible; there is no reliance
on the garbage collector. <span class="d_inlinecode"><a name="Array"></a><span class="ddoc_psymbol">Array</span></span> uses <span class="d_inlinecode">malloc</span> and <span class="d_inlinecode">free</span>
for managing its own memory.<p></p>

<dl><dt class="d_decl"><a name=".opEquals"></a>const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(const Array <i>rhs</i>);
<br><a name=".opEquals"></a>const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const Array <i>rhs</i>);
</dt>
<dd>Comparison for equality.<p></p>

</dd>
<dt class="d_decl"><a name=".Range"></a>struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</dt>
<dd>Defines the container's primary range, which is a random-access range.<p></p>

</dd>
<dt class="d_decl"><a name=".dup"></a>Array <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</dt>
<dd>Duplicates the container. The elements themselves are not transitively
duplicated.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".empty"></a>const bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has no
elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".length"></a>const size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
<br><a name=".opDollar"></a>const size_t <a name="opDollar"></a><span class="ddoc_psymbol">opDollar</span>();
</dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".capacity"></a>size_t <a name="capacity"></a><span class="ddoc_psymbol">capacity</span>();
</dt>
<dd>Returns the maximum number of elements the container can store without
   (a) allocating memory, (b) invalidating iterators upon insertion.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".reserve"></a>void <a name="reserve"></a><span class="ddoc_psymbol">reserve</span>(size_t <i>elements</i>);
</dt>
<dd>Ensures sufficient capacity to accommodate <span class="d_inlinecode">e</span> <i>elements</i>.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">capacity &gt;= e</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd>Returns a range that iterates over elements of the container, in
forward order.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>a</i>, size_t <i>b</i>);
</dt>
<dd>Returns <i>a</i> range that iterates over elements of the container from
index <span class="d_inlinecode"><i>a</i></span> up to (excluding) index <span class="d_inlinecode"><i>b</i></span>.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode"><i>a</i> &lt;= <i>b</i> &amp;&amp; <i>b</i> &lt;= length</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".front"></a>T <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".front"></a>void <a name="front"></a><span class="ddoc_psymbol">front</span>(T <i>value</i>);
<br><a name=".back"></a>T <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".back"></a>void <a name="back"></a><span class="ddoc_psymbol">back</span>(T <i>value</i>);
</dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span></span> and <span class="d_inlinecode">opSlice().back</span>, respectively.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opIndex"></a>T <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>i</i>);
<br><a name=".opIndexUnary"></a>void <a name="opIndexUnary"></a><span class="ddoc_psymbol">opIndexUnary</span>(string op)(size_t <i>i</i>) if (op == "++" || op == "--");
<br><a name=".opIndexUnary"></a>T <a name="opIndexUnary"></a><span class="ddoc_psymbol">opIndexUnary</span>(string op)(size_t <i>i</i>) if (op != "++" &amp;&amp; op != "--");
<br><a name=".opIndexAssign"></a>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(T <i>value</i>, size_t <i>i</i>);
<br><a name=".opIndexOpAssign"></a>void <a name="opIndexOpAssign"></a><span class="ddoc_psymbol">opIndexOpAssign</span>(string op)(T <i>value</i>, size_t <i>i</i>);
</dt>
<dd>Indexing operators yield or modify the value at a specified index.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode"><i>i</i> &lt; length</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opSliceAssign"></a>void <a name="opSliceAssign"></a><span class="ddoc_psymbol">opSliceAssign</span>(T <i>value</i>);
<br><a name=".opSliceUnary"></a>void <a name="opSliceUnary"></a><span class="ddoc_psymbol">opSliceUnary</span>(string op)(size_t <i>i</i>, size_t <i>j</i>) if (op == "++" || op == "--");
<br><a name=".opSliceOpAssign"></a>void <a name="opSliceOpAssign"></a><span class="ddoc_psymbol">opSliceOpAssign</span>(string op)(T <i>value</i>);
<br><a name=".opSliceOpAssign"></a>void <a name="opSliceOpAssign"></a><span class="ddoc_psymbol">opSliceOpAssign</span>(string op)(T <i>value</i>, size_t <i>i</i>, size_t <i>j</i>);
</dt>
<dd>Slicing operations execute an operation on an entire slice.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">i &lt; j &amp;&amp; j &lt; length</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">slice.length</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opBinary"></a>Array <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op, Stuff)(Stuff <i>stuff</i>) if (op == "~");
</dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span> and its
argument. <span class="d_inlinecode">opBinaryRight</span> is only defined if <span class="d_inlinecode">Stuff</span> does not
define <span class="d_inlinecode"><a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span></span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where m is the number of elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".opOpAssign"></a>void <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op, Stuff)(Stuff <i>stuff</i>) if (op == "~");
</dt>
<dd>Forwards to <span class="d_inlinecode">insertBack(stuff)</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</dt>
<dd>Removes all contents from the container. The container decides how <span class="d_inlinecode">capacity</span> is affected.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".length"></a>void <a name="length"></a><span class="ddoc_psymbol">length</span>(size_t <i>newLength</i>);
</dt>
<dd>Sets the number of elements in the container to <span class="d_inlinecode">newSize</span>. If <span class="d_inlinecode">newSize</span> is greater than <span class="d_inlinecode"><a name="length"></a><span class="ddoc_psymbol">length</span></span>, the added elements are added to
unspecified positions in the container and initialized with <span class="d_inlinecode">T.init</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">abs(n - <i>newLength</i>)</span><b><i>)</i></b>

<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode"><a name="length"></a><span class="ddoc_psymbol">length</span> == <i>newLength</i></span><p></p>

</dd>
<dt class="d_decl"><a name=".removeAny"></a>T <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
<br><a name=".stableRemoveAny"></a>alias <a name="stableRemoveAny"></a><span class="ddoc_psymbol">stableRemoveAny</span> = removeAny;
</dt>
<dd>Picks one value in an unspecified position in the container, removes
it from the container, and returns it. Implementations should pick the
value that's the most advantageous for the container, but document the
exact behavior. The stable version behaves the same, but guarantees
that ranges iterating over the container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".insertBack"></a>size_t <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff)(Stuff <i>stuff</i>) if (isImplicitlyConvertible!(Stuff, T) || isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T));
<br><a name=".insert"></a>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span> = insertBack;
</dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the front or back of the container. <span class="d_inlinecode">stuff</span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of
elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".removeBack"></a>void <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>();
<br><a name=".stableRemoveBack"></a>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span> = removeBack;
</dt>
<dd>Removes the value at the back of the container. The stable version
behaves the same, but guarantees that ranges iterating over the
container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".removeBack"></a>size_t <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>(size_t <i>howMany</i>);
<br><a name=".stableRemoveBack"></a>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span> = removeBack;
</dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
container. Unlike the unparameterized versions above, these functions
do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span> elements. Instead,
if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are removed. The returned value is
the effective number of elements removed. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>howMany</i></span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".insertBefore"></a>size_t <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (isImplicitlyConvertible!(Stuff, T));
<br><a name=".insertBefore"></a>size_t <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T));
<br><a name=".insertAfter"></a>size_t <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br><a name=".replace"></a>size_t <a name="replace"></a><span class="ddoc_psymbol">replace</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T));
<br><a name=".replace"></a>size_t <a name="replace"></a><span class="ddoc_psymbol">replace</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (isImplicitlyConvertible!(Stuff, T));
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> before, after, or instead range <span class="d_inlinecode">r</span>, which must
be a valid range previously extracted from this container. <span class="d_inlinecode">stuff</span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".linearRemove"></a>Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Range <i>r</i>);
<br><a name=".stableLinearRemove"></a>alias <a name="stableLinearRemove"></a><span class="ddoc_psymbol">stableLinearRemove</span> = remove;
</dt>
<dd>Removes all elements belonging to <span class="d_inlinecode"><i>r</i></span>, which must be a range
obtained originally from this container. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>A range spanning the remaining elements in the container that
initially were right after <span class="d_inlinecode"><i>r</i></span>.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n - m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of elements in
<span class="d_inlinecode"><i>r</i></span><p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".BinaryHeap"></a>struct <a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span>(Store, alias less = "a &lt; b") if (isRandomAccessRange!Store || isRandomAccessRange!(typeof(Store.init[])));
</dt>
<dd>Implements a <a href="http://en.wikipedia.org/wiki/Binary_heap">binary heap</a>
container on top of a given random-access range type (usually <span class="d_inlinecode">T[]</span>) or a random-access container type (usually <span class="d_inlinecode">Array!T</span>). The
documentation of <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> will refer to the underlying range or
container as the <i>store</i> of the heap.
<p></p>
The binary heap induces structure over the underlying store such that
accessing the largest element (by using the <span class="d_inlinecode">front</span> property) is a
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b> operation and extracting it (by using the <span class="d_inlinecode">removeFront()</span> method) is done fast in <b><i>&Omicron;</i>(</b><span class="d_inlinecode">log n</span><b><i>)</i></b> time.
<p></p>

If <span class="d_inlinecode">less</span> is the less-than operator, which is the default option,
then <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> defines a so-called max-heap that optimizes
extraction of the <i>largest</i> elements. To define a min-heap,
instantiate <a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span> with <span class="d_inlinecode">"a &gt; b"</span> as its predicate.
<p></p>

Simply extracting elements from a <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> container is
tantamount to lazily fetching elements of <span class="d_inlinecode">Store</span> in descending
order. Extracting elements from the <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> to completion
leaves the underlying store sorted in ascending order but, again,
yields elements in descending order.
<p></p>

If <span class="d_inlinecode">Store</span> is a range, the <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> cannot grow beyond the
size of that range. If <span class="d_inlinecode">Store</span> is a container that supports <span class="d_inlinecode">insertBack</span>, the <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> may grow by adding elements to the
container.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Example from "Introduction to Algorithms" Cormen et al, p 146
</span><span class="d_keyword">int</span>[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];
<span class="d_keyword">auto</span> h = heapify(a);
<span class="d_comment">// largest element
</span><span class="d_keyword">assert</span>(h.front == 16);
<span class="d_comment">// a has the heap property
</span><span class="d_keyword">assert</span>(equal(a, [ 16, 14, 10, 9, 8, 7, 4, 3, 2, 1 ]));
</pre>
<p></p>

<dl><dt class="d_decl"><a name=".this"></a> this(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</dt>
<dd>Converts the store <span class="d_inlinecode"><i>s</i></span> into a heap. If <span class="d_inlinecode"><i>initialSize</i></span> is
       specified, only the first <span class="d_inlinecode"><i>initialSize</i></span> elements in <span class="d_inlinecode"><i>s</i></span>
       are transformed into a heap, after which the heap can grow up
       to <span class="d_inlinecode">r.length</span> (if <span class="d_inlinecode">Store</span> is a range) or indefinitely (if
       <span class="d_inlinecode">Store</span> is a container with <span class="d_inlinecode">insertBack</span>). Performs
       <b><i>&Omicron;</i>(</b><span class="d_inlinecode">min(r.length, <i>initialSize</i>)</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">less</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".acquire"></a>void <a name="acquire"></a><span class="ddoc_psymbol">acquire</span>(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</dt>
<dd>Takes ownership of a store. After this, manipulating <span class="d_inlinecode"><i>s</i></span> may make
the heap work incorrectly.<p></p>

</dd>
<dt class="d_decl"><a name=".assume"></a>void <a name="assume"></a><span class="ddoc_psymbol">assume</span>(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</dt>
<dd>Takes ownership of a store assuming it already was organized as a
heap.<p></p>

</dd>
<dt class="d_decl"><a name=".release"></a>auto <a name="release"></a><span class="ddoc_psymbol">release</span>();
</dt>
<dd>Clears the heap. Returns the portion of the store from <span class="d_inlinecode">0</span> up to
<span class="d_inlinecode">length</span>, which satisfies the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=heap property">heap property</a>.<p></p>

</dd>
<dt class="d_decl"><a name=".empty"></a>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if the heap is empty, <span class="d_inlinecode"><b>false</b></span> otherwise.<p></p>

</dd>
<dt class="d_decl"><a name=".dup"></a>BinaryHeap <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</dt>
<dd>Returns a duplicate of the heap. The underlying store must also
support a <span class="d_inlinecode"><a name="dup"></a><span class="ddoc_psymbol">dup</span></span> method.<p></p>

</dd>
<dt class="d_decl"><a name=".length"></a>size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd>Returns the length of the heap.<p></p>

</dd>
<dt class="d_decl"><a name=".capacity"></a>size_t <a name="capacity"></a><span class="ddoc_psymbol">capacity</span>();
</dt>
<dd>Returns the capacity of the heap, which is the length of the
underlying store (if the store is a range) or the capacity of the
underlying store (if the store is a container).<p></p>

</dd>
<dt class="d_decl"><a name=".front"></a>ElementType!Store <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>Returns a copy of the front of the heap, which is the largest element
according to <span class="d_inlinecode">less</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</dt>
<dd>Clears the heap by detaching it from the underlying store.<p></p>

</dd>
<dt class="d_decl"><a name=".insert"></a>size_t <a name="insert"></a><span class="ddoc_psymbol">insert</span>(ElementType!Store <i>value</i>);
</dt>
<dd>Inserts <span class="d_inlinecode"><i>value</i></span> into the store. If the underlying store is a range
and <span class="d_inlinecode">length == capacity</span>, throws an exception.<p></p>

</dd>
<dt class="d_decl"><a name=".removeFront"></a>void <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>();
</dt>
<dd>Removes the largest element from the heap.<p></p>

</dd>
<dt class="d_decl"><a name=".removeAny"></a>ElementType!Store <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
</dt>
<dd>Removes the largest element from the heap and returns a copy of
it. The element still resides in the heap's store. For performance
reasons you may want to use <span class="d_inlinecode">removeFront</span> with heaps of objects
that are expensive to copy.<p></p>

</dd>
<dt class="d_decl"><a name=".replaceFront"></a>void <a name="replaceFront"></a><span class="ddoc_psymbol">replaceFront</span>(ElementType!Store <i>value</i>);
</dt>
<dd>Replaces the largest element in the store with <span class="d_inlinecode"><i>value</i></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".conditionalInsert"></a>bool <a name="conditionalInsert"></a><span class="ddoc_psymbol">conditionalInsert</span>(ElementType!Store <i>value</i>);
</dt>
<dd>If the heap has room to grow, inserts <span class="d_inlinecode"><i>value</i></span> into the store and
returns <span class="d_inlinecode"><b>true</b></span>. Otherwise, if <span class="d_inlinecode">less(<i>value</i>, front)</span>, calls <span class="d_inlinecode">replaceFront(<i>value</i>)</span> and returns again <span class="d_inlinecode"><b>true</b></span>. Otherwise, leaves
the heap unaffected and returns <span class="d_inlinecode"><b>false</b></span>. This method is useful in
scenarios where the smallest <span class="d_inlinecode">k</span> elements of a set of candidates
must be collected.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".heapify"></a>BinaryHeap!(Store, less) <a name="heapify"></a><span class="ddoc_psymbol">heapify</span>(alias less = "a &lt; b", Store)(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</dt>
<dd>Convenience function that returns a <span class="d_inlinecode">BinaryHeap!Store</span> object
initialized with <span class="d_inlinecode">s</span> and <span class="d_inlinecode">initialSize</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array"></a>struct <a name="Array"></a><span class="ddoc_psymbol">Array</span>(T) if (is(T == bool));
</dt>
<dd>Array specialized for <span class="d_inlinecode">bool</span>. Packs together values efficiently by
allocating one bit per element.<p></p>

<dl><dt class="d_decl"><a name=".Range"></a>struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</dt>
<dd>Defines the container's primary range.<p></p>

<dl><dt class="d_decl"><a name=".save"></a>Range <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br><a name=".empty"></a>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".front"></a>T <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".front"></a>void <a name="front"></a><span class="ddoc_psymbol">front</span>(bool <i>value</i>);
<br><a name=".moveFront"></a>T <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>();
<br><a name=".popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".back"></a>T <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".moveBack"></a>T <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>();
<br><a name=".popBack"></a>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
<br><a name=".opIndex"></a>T <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>i</i>);
<br><a name=".opIndexAssign"></a>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(T <i>value</i>, size_t <i>i</i>);
<br><a name=".moveAt"></a>T <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t <i>i</i>);
<br><a name=".length"></a>const ulong <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd>Range primitives<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".empty"></a>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has
       no elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".dup"></a>Array!bool <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</dt>
<dd>Returns a duplicate of the container. The elements themselves
       are not transitively duplicated.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".length"></a>ulong <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".capacity"></a>ulong <a name="capacity"></a><span class="ddoc_psymbol">capacity</span>();
</dt>
<dd>Returns the maximum number of elements the container can store
       without (a) allocating memory, (b) invalidating iterators upon
       insertion.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".reserve"></a>void <a name="reserve"></a><span class="ddoc_psymbol">reserve</span>(ulong <i>e</i>);
</dt>
<dd>Ensures sufficient capacity to accommodate <span class="d_inlinecode">n</span> elements.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">capacity &gt;= n</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(<i>e</i> - capacity)</span><b><i>)</i></b> if <span class="d_inlinecode"><i>e</i> &gt; capacity</span>,
       otherwise <b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd>Returns a range that iterates over all elements of the
       container, in a container-defined order. The container should
       choose the most convenient and fast method of iteration for <span class="d_inlinecode">      <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>()</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(ulong <i>a</i>, ulong <i>b</i>);
</dt>
<dd>Returns <i>a</i> range that iterates the container between two
       specified positions.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".front"></a>bool <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".front"></a>void <a name="front"></a><span class="ddoc_psymbol">front</span>(bool <i>value</i>);
<br><a name=".back"></a>bool <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".back"></a>void <a name="back"></a><span class="ddoc_psymbol">back</span>(bool <i>value</i>);
</dt>
<dd>Equivalent to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span></span> and <span class="d_inlinecode">opSlice().back</span>,
       respectively.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opIndex"></a>bool <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(ulong <i>i</i>);
<br><a name=".opIndexAssign"></a>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(bool <i>value</i>, ulong <i>i</i>);
<br><a name=".opIndexOpAssign"></a>void <a name="opIndexOpAssign"></a><span class="ddoc_psymbol">opIndexOpAssign</span>(string op)(bool <i>value</i>, ulong <i>i</i>);
<br><a name=".moveAt"></a>T <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(ulong <i>i</i>);
</dt>
<dd>Indexing operators yield or modify the value at a specified index.<p></p>

</dd>
<dt class="d_decl"><a name=".opBinary"></a>Array!bool <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op, Stuff)(Stuff <i>rhs</i>) if (op == "~");
</dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span>
       and its argument.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where m is the number of elements
       in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".opOpAssign"></a>Array!bool <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op, Stuff)(Stuff <i>stuff</i>) if (op == "~");
</dt>
<dd>Forwards to <span class="d_inlinecode">insertAfter(this[], stuff)</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</dt>
<dd>Removes all contents from the container. The container decides
       how <span class="d_inlinecode">capacity</span> is affected.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".length"></a>void <a name="length"></a><span class="ddoc_psymbol">length</span>(ulong <i>newLength</i>);
</dt>
<dd>Sets the number of elements in the container to <span class="d_inlinecode">      newSize</span>. If <span class="d_inlinecode">newSize</span> is greater than <span class="d_inlinecode"><a name="length"></a><span class="ddoc_psymbol">length</span></span>, the
       added elements are added to the container and initialized with
       <span class="d_inlinecode">ElementType.init</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">abs(n - <i>newLength</i>)</span><b><i>)</i></b>

<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">length == <i>newLength</i></span><p></p>

</dd>
<dt class="d_decl"><a name=".insert"></a>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span> = insertBack;
<br><a name=".stableInsert"></a>alias <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span> = insertBack;
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> in the container. <span class="d_inlinecode">stuff</span> can be a value
       convertible to <span class="d_inlinecode">ElementType</span> or a range of objects
       convertible to <span class="d_inlinecode">ElementType</span>.
<p></p>
The <span class="d_inlinecode">stable</span> version guarantees that ranges iterating over
       the container are never invalidated. Client code that counts on
       non-invalidating insertion should use <span class="d_inlinecode">stableInsert</span>.

<p></p>
<b>Returns:</b><br>The number of elements added.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of
       elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".linearInsert"></a>alias <a name="linearInsert"></a><span class="ddoc_psymbol">linearInsert</span> = insertBack;
<br><a name=".stableLinearInsert"></a>alias <a name="stableLinearInsert"></a><span class="ddoc_psymbol">stableLinearInsert</span> = insertBack;
</dt>
<dd>Same as <span class="d_inlinecode">insert(stuff)</span> and <span class="d_inlinecode">stableInsert(stuff)</span>
       respectively, but relax the complexity constraint to linear.<p></p>

</dd>
<dt class="d_decl"><a name=".removeAny"></a>T <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
<br><a name=".stableRemoveAny"></a>alias <a name="stableRemoveAny"></a><span class="ddoc_psymbol">stableRemoveAny</span> = removeAny;
</dt>
<dd>Picks one value in the container, removes it from the
       container, and returns it. The stable version behaves the same,
       but guarantees that ranges iterating over the container are
       never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".insertBack"></a>ulong <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff)(Stuff <i>stuff</i>) if (is(Stuff : bool));
<br><a name=".insertBack"></a>ulong <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff)(Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; is(ElementType!Stuff : bool));
<br><a name=".stableInsertBack"></a>alias <a name="stableInsertBack"></a><span class="ddoc_psymbol">stableInsertBack</span> = insertBack;
</dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the back of the container. <span class="d_inlinecode">stuff</span> can
       be a value convertible to <span class="d_inlinecode">ElementType</span> or a range of
       objects convertible to <span class="d_inlinecode">ElementType</span>. The stable version
       behaves the same, but guarantees that ranges iterating over the
       container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".removeBack"></a>void <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>();
<br><a name=".stableRemoveBack"></a>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span> = removeBack;
</dt>
<dd>Removes the value at the front or back of the container. The
       stable version behaves the same, but guarantees that ranges
       iterating over the container are never invalidated. The
       optional parameter <span class="d_inlinecode">howMany</span> instructs removal of that many
       elements. If <span class="d_inlinecode">howMany &gt; n</span>, all elements are removed and no
       exception is thrown.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".removeBack"></a>ulong <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>(ulong <i>howMany</i>);
</dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
       container. Unlike the unparameterized versions above, these
       functions do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span>
       elements. Instead, if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are
       removed. The returned value is the effective number of elements
       removed. The stable version behaves the same, but guarantees
       that ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>howMany</i> * log(n)</span><b><i>)</i></b>.
     
 ditto<p></p>

</dd>
<dt class="d_decl"><a name=".insertBefore"></a>ulong <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br><a name=".stableInsertBefore"></a>alias <a name="stableInsertBefore"></a><span class="ddoc_psymbol">stableInsertBefore</span> = insertBefore;
<br><a name=".insertAfter"></a>ulong <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br><a name=".stableInsertAfter"></a>alias <a name="stableInsertAfter"></a><span class="ddoc_psymbol">stableInsertAfter</span> = insertAfter;
<br><a name=".replace"></a>size_t <a name="replace"></a><span class="ddoc_psymbol">replace</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (is(Stuff : bool));
<br><a name=".stableReplace"></a>alias <a name="stableReplace"></a><span class="ddoc_psymbol">stableReplace</span> = replace;
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> before, after, or instead range <span class="d_inlinecode">r</span>,
       which must be a valid range previously extracted from this
       container. <span class="d_inlinecode">stuff</span> can be a value convertible to <span class="d_inlinecode">      ElementType</span> or a range of objects convertible to <span class="d_inlinecode">      ElementType</span>. The stable version behaves the same, but
       guarantees that ranges iterating over the container are never
       invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".linearRemove"></a>Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Range <i>r</i>);
<br><a name=".stableLinearRemove"></a>alias <a name="stableLinearRemove"></a><span class="ddoc_psymbol">stableLinearRemove</span> = linearRemove;
</dt>
<dd>Removes all elements belonging to <span class="d_inlinecode"><i>r</i></span>, which must be a range
       obtained originally from this container. The stable version
       behaves the same, but guarantees that ranges iterating over the
       container are never invalidated.
<p></p>
<b>Returns:</b><br>A range spanning the remaining elements in the container that
       initially were right after <span class="d_inlinecode"><i>r</i></span>.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".RedBlackTree"></a>class <a name="RedBlackTree"></a><span class="ddoc_psymbol">RedBlackTree</span>(T, alias less = "a &lt; b", bool allowDuplicates = false) if (is(typeof(binaryFun!less(T.init, T.init))));
</dt>
<dd>Implementation of a <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=red-black tree">red-black tree</a> container.
<p></p>
All inserts, removes, searches, and any function in general has complexity
 of <b><i>&Omicron;</i>(</b><span class="d_inlinecode">lg(n)</span><b><i>)</i></b>.
<p></p>

 To use a different comparison than <span class="d_inlinecode">"a &lt; b"</span>, pass a different operator string
 that can be used by <a href="std_functional.html#binaryFun"><span class="d_inlinecode">std.functional.binaryFun</span></a>, or pass in a
 function, delegate, functor, or any type where <span class="d_inlinecode">less(a, b)</span> results in a <span class="d_inlinecode">bool</span>
 value.
<p></p>

 Note that less should produce a strict ordering.  That is, for two unequal
 elements <span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span>, <span class="d_inlinecode">less(a, b) == !less(b, a)</span>. <span class="d_inlinecode">less(a, a)</span> should
 always equal <span class="d_inlinecode"><b>false</b></span>.
<p></p>

 If <span class="d_inlinecode">allowDuplicates</span> is set to <span class="d_inlinecode"><b>true</b></span>, then inserting the same element more than
 once continues to add more elements.  If it is <span class="d_inlinecode"><b>false</b></span>, duplicate elements are
 ignored on insertion.  If duplicates are allowed, then new elements are
 inserted after all existing duplicate elements.<p></p>

<dl><dt class="d_decl"><a name=".Elem"></a>alias <a name="Elem"></a><span class="ddoc_psymbol">Elem</span> = T;
</dt>
<dd>Element type for the tree<p></p>

</dd>
<dt class="d_decl"><a name=".Range"></a>struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</dt>
<dd>The range type for <span class="d_inlinecode">RedBlackTree</span><p></p>

<dl><dt class="d_decl"><a name=".empty"></a>const bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if the range is empty<p></p>

</dd>
<dt class="d_decl"><a name=".front"></a>Elem <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>Returns the first element in the range<p></p>

</dd>
<dt class="d_decl"><a name=".back"></a>Elem <a name="back"></a><span class="ddoc_psymbol">back</span>();
</dt>
<dd>Returns the last element in the range<p></p>

</dd>
<dt class="d_decl"><a name=".popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd>pop the front element from the range
<p></p>
<b>complexity:</b><br>
amortized <b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".popBack"></a>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
</dt>
<dd>pop the back element from the range
<p></p>
<b>complexity:</b><br>
amortized <b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".save"></a>Range <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd>Trivial save implementation, needed for <span class="d_inlinecode">isForwardRange</span>.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".empty"></a>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Check if any elements exist in the container.  Returns <span class="d_inlinecode"><b>false</b></span> if at least
 one element exists.<p></p>

</dd>
<dt class="d_decl"><a name=".length"></a>size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".dup"></a>RedBlackTree <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</dt>
<dd>Duplicate this container.  The resulting container contains a shallow
 copy of the elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd>Fetch a range that spans all the elements in the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".front"></a>Elem <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>The <a name="front"></a><span class="ddoc_psymbol">front</span> element in the container
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".back"></a>Elem <a name="back"></a><span class="ddoc_psymbol">back</span>();
</dt>
<dd>The last element in the container
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opBinaryRight"></a>bool <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(string op)(Elem <i>e</i>) if (op == "in");
</dt>
<dd><span class="d_inlinecode">in</span> operator. Check to see if the given element exists in the
        container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".opEquals"></a>bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(Object <i>rhs</i>);
</dt>
<dd>Compares two trees for equality.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n*log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</dt>
<dd>Removes all elements from the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".stableInsert"></a>size_t <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span>(Stuff)(Stuff <i>stuff</i>) if (isImplicitlyConvertible!(Stuff, Elem));
</dt>
<dd>Insert a single element in the container.  Note that this does not
 invalidate any ranges currently iterating the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".stableInsert"></a>size_t <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span>(Stuff)(Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, Elem));
<br><a name=".insert"></a>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span> = stableInsert;
</dt>
<dd>Insert a range of elements in the container.  Note that this does not
 invalidate any ranges currently iterating the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".removeAny"></a>Elem <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
</dt>
<dd>Remove an element from the container and return its value.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".removeFront"></a>void <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>();
</dt>
<dd>Remove the front element from the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".removeBack"></a>void <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>();
</dt>
<dd>Remove the back element from the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".remove"></a>Range <a name="remove"></a><span class="ddoc_psymbol">remove</span>(Range <i>r</i>);
</dt>
<dd>Removes the given range from the container.
<p></p>
<b>Returns:</b><br>A range containing all of the elements that were after the
                 given range.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b> (where m is the number of elements in
                    the range)<p></p>

</dd>
<dt class="d_decl"><a name=".remove"></a>Range <a name="remove"></a><span class="ddoc_psymbol">remove</span>(Take!Range <i>r</i>);
</dt>
<dd>Removes the given <span class="d_inlinecode">Take!Range</span> from the container
<p></p>
<b>Returns:</b><br>A range containing all of the elements that were after the
                 given range.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b> (where m is the number of elements in
                    the range)<p></p>

</dd>
<dt class="d_decl"><a name=".removeKey"></a>size_t <a name="removeKey"></a><span class="ddoc_psymbol">removeKey</span>(U...)(U <i>elems</i>) if (allSatisfy!(isImplicitlyConvertibleToElem, U));
<br><a name=".removeKey"></a>size_t <a name="removeKey"></a><span class="ddoc_psymbol">removeKey</span>(U)(U[] <i>elems</i>) if (isImplicitlyConvertible!(U, Elem));
<br><a name=".removeKey"></a>size_t <a name="removeKey"></a><span class="ddoc_psymbol">removeKey</span>(Stuff)(Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, Elem) &amp;&amp; !isDynamicArray!Stuff);
</dt>
<dd>Removes elements from the container that are equal to the given values
       according to the less comparator. One element is removed for each value
       given which is in the container. If <span class="d_inlinecode">allowDuplicates</span> is <b>true</b>,
       duplicates are removed only if duplicate values are given.
<p></p>
<b>Returns:</b><br>The number of elements removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m log(n)</span><b><i>)</i></b> (where m is the number of elements to remove)

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> rbt = redBlackTree!<span class="d_keyword">true</span>(0, 1, 1, 1, 4, 5, 7);
rbt.<span class="d_psymbol">removeKey</span>(1, 4, 7);
<span class="d_keyword">assert</span>(std.algorithm.equal(rbt[], [0, 1, 1, 5]));
rbt.<span class="d_psymbol">removeKey</span>(1, 1, 0);
<span class="d_keyword">assert</span>(std.algorithm.equal(rbt[], [5]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".upperBound"></a>Range <a name="upperBound"></a><span class="ddoc_psymbol">upperBound</span>(Elem <i>e</i>);
</dt>
<dd>Get a range from the container with all elements that are &gt; <i>e</i> according
 to the less comparator
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".lowerBound"></a>Range <a name="lowerBound"></a><span class="ddoc_psymbol">lowerBound</span>(Elem <i>e</i>);
</dt>
<dd>Get a range from the container with all elements that are &lt; <i>e</i> according
 to the less comparator
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".equalRange"></a>Range <a name="equalRange"></a><span class="ddoc_psymbol">equalRange</span>(Elem <i>e</i>);
</dt>
<dd>Get a range from the container with all elements that are == <i>e</i> according
 to the less comparator
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".this"></a> this();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".this"></a> this(Elem[] <i>elems</i>...);
</dt>
<dd>Constructor.  Pass in an array of elements, or individual elements to
       initialize the tree with.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".redBlackTree"></a>auto <a name="redBlackTree"></a><span class="ddoc_psymbol">redBlackTree</span>(E)(E[] <i>elems</i>...);
<br><a name=".redBlackTree"></a>auto <a name="redBlackTree"></a><span class="ddoc_psymbol">redBlackTree</span>(bool allowDuplicates, E)(E[] <i>elems</i>...);
<br><a name=".redBlackTree"></a>auto <a name="redBlackTree"></a><span class="ddoc_psymbol">redBlackTree</span>(alias less, E)(E[] <i>elems</i>...);
<br><a name=".redBlackTree"></a>auto <a name="redBlackTree"></a><span class="ddoc_psymbol">redBlackTree</span>(alias less, bool allowDuplicates, E)(E[] <i>elems</i>...) if (is(typeof(binaryFun!less(E.init, E.init))));
</dt>
<dd>Convenience function for creating a <span class="d_inlinecode">RedBlackTree!E</span> from a list of
    values.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> rbt1 = <span class="d_psymbol">redBlackTree</span>(0, 1, 5, 7);
<span class="d_keyword">auto</span> rbt2 = <span class="d_psymbol">redBlackTree</span>!string(<span class="d_string">"hello"</span>, <span class="d_string">"world"</span>);
<span class="d_keyword">auto</span> rbt3 = <span class="d_psymbol">redBlackTree</span>!<span class="d_keyword">true</span>(0, 1, 5, 7, 5);
<span class="d_keyword">auto</span> rbt4 = <span class="d_psymbol">redBlackTree</span>!<span class="d_string">"a &gt; b"</span>(0, 1, 5, 7);
<span class="d_keyword">auto</span> rbt5 = <span class="d_psymbol">redBlackTree</span>!(<span class="d_string">"a &gt; b"</span>, <span class="d_keyword">true</span>)(0.1, 1.3, 5.9, 7.2, 5.9);
</pre>
<p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code
copyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.

 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
